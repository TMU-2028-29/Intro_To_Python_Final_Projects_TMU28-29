"""
PROBLEM: Goal is to build my own spellchecker (autocorrect) from scratch
The script would take in a input file, and output the corrected text to console and an output file
I plan to use levenshtein's algorithm to compute the distacnce bettween 2 words if i calculates a word
dosent exist, this algorithm finds the edit distance between 2 words using only insertion, deletion and subsitution'
I will also use a dictonary file of a large set of valid english words taken from the internet to check if a word is valid

HOW IT WORKS:
	•	Loads a dictonary of valid words
    •	Iterate through every word to check if it is valid
    •	If Not valid, use Levenshtiens algorithm to find the closest valid word and replace
    •	Reassemble and display the final output

(Yes it runs the levenshtein_dist funcion for every non-valid word, against every dict word)

*it will be ~70% accurate, without more complicated launguage model type stuff this is the best it will get
*instead of manually fixing the errors, i left them in to show what the script can truly do in a real world situation
*the example inputs were generated by chatgpt and unmodified "Generate a 2 paragraph text on anything with moderate spelling issues everywhere"
"""
import os

# Creates a dict of lowercase words for the dictonary from dictonary.txt
def load_dictionary(dict_file):
    with open(dict_file, 'r') as f:
        dictionary = set(word.strip().lower() for word in f.readlines())
    return dictionary

#Checks if a word exists in the dictonary already 
def valid_word(word, dictionary):
    return word.lower() in dictionary

#Computes the max amount of edits(distance) bettween 2 words
# uses ONLY subsitution, insertion and deletion to calculate
def levenshtein_dist(word1, word2):
    #make sure word 1 is larger then word 2
    if len(word1) < len(word2):
        word1, word2 = word2, word1

    # create the row with distances for transforming 
    distances = list(range(len(word2) + 1))
    #initally distances[x] holds the edit distance bettween the first x charachters of word2
    
    #loops over every charchter in word 1 / basically building word 1 letter by letter
    for i in range(1, len(word1) + 1):
        previous = distances[0]  # log the top-left corner value for substitution
        distances[0] = i  # Update the first position on the current row

        #loops over word 2 / basically building word 2 letter by letter like before
        for x in range(1, len(word2) + 1):
            current = distances[x] #stores current value of distances[x], same column, prev row 
            # check if the current pos of word 1 and 2 match, if not then no cost, if they differ then a cost of 1 for subsitution
            cost = 0 if word1[i - 1] == word2[x - 1] else 1
            # update the edit distance for this cell by taking the min of these 3 operations
            distances[x] = min(
                distances[x] + 1,     #deletion
                distances[x - 1] + 1, #insertion
                previous + cost       #substitution
            )
            previous = current  # move to next 

    return distances[-1] #returns final value in the distances list, which is the final edit dist bettween words 1 and 2 


# Function to suggest the closest valid word from the dictionary
def correction(word, dictionary):
    # assume the first letter is always correct, this speeds up the program by like 10x
    filtered_dict = [dict_word for dict_word in dictionary if dict_word[0] == word[0]]
    
    closest_match = word  # Default to the word itself
    min_distance = float('inf')  # Start with a very large distance
    
    # Check all words in the dictionary, tedious but 100% right
    for dict_word in filtered_dict:
        dist = levenshtein_dist(word, dict_word)
        if dist < min_distance:
            min_distance = dist
            closest_match = dict_word
    
    return closest_match


corrected_words = {} # for final output of words that are corrected

# Function to autocorrect text
def autocorrect_text(input_file, output_file, dictionary):
    with open(input_file, 'r') as infile, open(output_file, 'w') as outfile:
        word_counter = 0 # count index of word
        
        for line in infile: #For line in file
            words = line.split()  # split the line into each word
            corrected_line = [] 

            for word in words:
                # count words for printing changes step at the end
                word_counter += 1
                
                # remove punctuation for word comparison
                clean_word = ''.join(char for char in word if char.isalnum())
                
                if valid_word(clean_word, dictionary):
                    corrected_line.append(word)  # If word exists, keep it the same
                else:
                    corrected_word = correction(clean_word, dictionary)
                    # Replace the word with the corrected word
                    corrected_line.append(word.replace(clean_word, corrected_word))
                    
                    corrected_words[word_counter] = (clean_word, corrected_word)
                    
                
            
            # Join the corrected words back into a line and write to output file
            outfile.write(' '.join(corrected_line) + '\n')


#MAIN SCRIPT 

input_file = 'input.txt'  # File Path To The Input File
output_file = 'output.txt'  # File Path To The Output File
dict_file = 'dictionary.txt'  # File Path f


print("--AUTOCORRECTOR--")
dictionary = load_dictionary(dict_file)
print("loaded dict")
#Files that shouldnt be used as input
exclude_files = {'dictionary.txt', 'output.txt', 'Project.py', ".DS_Store", "cps109_a1.py", "cps109_a1.py.png"} 
#Get all files in directory
file_list = [f for f in os.listdir('./') if os.path.isfile(f)]
#Remove the files that shouldnt be an input option
file_list = [f for f in file_list if f not in exclude_files]
#Sometimes example inputs woulr be in the wrong order and it was annoying me
file_list = sorted(file_list)
print("loaded files")

user_input = False
while not user_input:
    print("\nWhich file would you like to correct?\n")
    #print out valid options
    i = 1
    for x in file_list:
        print(i, ") ", x)
        i += 1
        
    try:
        c = int(input("Selection: "))
    except ValueError:
        print("Invalid input, please enter a number.\n")
        continue
    
    if c > 0 and c < i:
        input_file = file_list[c-1]
        user_input = True
    else:
        print("That is not an option, try again.\n")

print("Correcting ", input_file, " to output.txt and console.")
#Run the autocorrect function
autocorrect_text(input_file, output_file, dictionary)

#Print Original
print("----------------------------ORIGINAL TEXT----------------------------")
with open(input_file, 'r') as file:
    print(file.read())
#Print Final
print("----------------------------OUTPUT TEXT----------------------------")
with open(output_file, 'r') as file:
    print(file.read())
    
print("\n\nTOTAL CHANGES MADE: ", (len(corrected_words) -1))
    
print("----------------------------LIST OF CHANGES----------------------------")


#Print all changes
for index, (original, corrected) in corrected_words.items():
    print("Word ",index," changed from ",original," --> ",corrected)

